<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>常用分布式ID解决方案 | 时刻准备着</title>
    <meta name="description" content="常用分布式ID解决方案">
    <link rel="stylesheet" href="/blog/assets/style.9243fa93.css">
    <link rel="modulepreload" href="/blog/assets/Home.e1d18961.js">
    <link rel="modulepreload" href="/blog/assets/app.696abebf.js">
    <link rel="modulepreload" href="/blog/assets/posts_常用分布式ID解决方案.md.9856da27.lean.js">
    
    <meta name="twitter:title" content="常用分布式ID解决方案 | 时刻准备着">
  <meta property="og:title" content="常用分布式ID解决方案 | 时刻准备着">
  </head>
  <body>
    <div id="app"><!--[--><div id="cssid" class="theme" data-v-3eaa5914><!--[--><div class="theme"><header class="nav-bar" data-v-40587210><div class="sidebar-button" data-v-40587210><svg class="icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z" class></path></svg></div><a class="nav-bar-title" href="/blog/" aria-label="时刻准备着, back to home" data-v-40587210 data-v-7ac13a1e><!----> 时刻准备着</a><div class="flex-grow" data-v-40587210></div><div class="nav" data-v-40587210><nav class="nav-links" data-v-40587210 data-v-35b91e7e><!--[--><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item" href="/blog/" data-v-49fe041d>主页 <!----></a></div></div><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item" href="/blog/pages/archives" data-v-49fe041d>归档 <!----></a></div></div><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item" href="/blog/pages/tags" data-v-49fe041d>分类 <!----></a></div></div><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item" href="/blog/pages/about" data-v-49fe041d>关于 <!----></a></div></div><!--]--><!----><!----></nav></div><!--[--><!--]--></header><aside class="sidebar" data-v-17c48e2f><nav class="nav-links nav" data-v-17c48e2f data-v-35b91e7e><!--[--><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item" href="/blog/" data-v-49fe041d>主页 <!----></a></div></div><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item" href="/blog/pages/archives" data-v-49fe041d>归档 <!----></a></div></div><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item" href="/blog/pages/tags" data-v-49fe041d>分类 <!----></a></div></div><div class="item" data-v-35b91e7e><div class="nav-link" data-v-35b91e7e data-v-49fe041d><a class="item" href="/blog/pages/about" data-v-49fe041d>关于 <!----></a></div></div><!--]--><!----><!----></nav><!--[--><!--]--><ul class="sidebar-links" data-v-17c48e2f><!--[--><li class="sidebar-link"><a class="sidebar-link-item" href="#_1-什么是分布式id？">1.什么是分布式id？</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#_2-分布式id满足条件">2.分布式id满足条件</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#_1、uuid">1、UUID</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#优点：">优点：</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#缺点：">缺点：</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#_2-数据库主键自增">2.数据库主键自增</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#优点：-1">优点：</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#缺点：-1">缺点：</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#_3、基于数据库集群模式">3、基于数据库集群模式</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#优点：-2">优点：</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#缺点：-2">缺点：</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#_4、基于数据库号段模式">4、基于数据库号段模式</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#优点：-3">优点：</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#缺点：-3">缺点：</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#_5、基于redis模式">5、基于redis模式</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#优点：-4">优点：</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#缺点：-4">缺点：</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#_6、基于mongodb-objectid">6、基于MongoDB ObjectId</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#优点-：">优点 ：</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#缺点-：">缺点 ：</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#_7、基于snowflake（雪花算法）模式">7、基于snowflake（雪花算法）模式</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#优点：-5">优点：</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#缺点：-5">缺点：</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#_8、百度（uid-generator）">8、百度（uid-generator）</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#_9、美团（leaf）">9、美团（Leaf）</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#_10、滴滴（tinyid）">10、滴滴（Tinyid）</a><!----></li><!--]--></ul><!--[--><!--]--></aside><div class="sidebar-mask"></div><main class="page" data-v-8fcebc32><div class="container" data-v-8fcebc32><!--[--><!--]--><div style="position:relative;" class="content" data-v-8fcebc32><div><h1 id="" tabindex="-1"><img src="https://cdn.nlark.com/yuque/0/2022/png/25635684/1641348787471-e489ef4f-d7fe-4a71-b8e9-f180300fc113.png#clientId=u16403895-af71-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u4478e249&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=338&amp;originWidth=720&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=101603&amp;status=done&amp;style=none&amp;taskId=u776fd6e4-2c91-4ec5-a0f7-002f15cf47d&amp;title=" alt="image.png"> <a class="header-anchor" href="#" aria-hidden="true">#</a></h1><h1 id="一、为什么用分布式id？" tabindex="-1">一、为什么用分布式id？ <a class="header-anchor" href="#一、为什么用分布式id？" aria-hidden="true">#</a></h1><h2 id="_1-什么是分布式id？" tabindex="-1">1.什么是分布式id？ <a class="header-anchor" href="#_1-什么是分布式id？" aria-hidden="true">#</a></h2><p>分布式id是依托于分布式系统诞生的概念。 分布式id是分布式系统中一个重要的概念。 拿pg举例，以前我们的项目用户量少可能需要单机pg就够用了，但是随着时间的推移，用户量也极具上升，单机已无法满足业务需求，所以我们将单机更换为了集群并进行了分库分表。 集群搭建之后，数据存放于不同的DB，如果使用传统的方式（数据库自增主键），就无法保证全局唯一，所以此时急需一种可以生成全局id的系统。</p><h2 id="_2-分布式id满足条件" tabindex="-1">2.分布式id满足条件 <a class="header-anchor" href="#_2-分布式id满足条件" aria-hidden="true">#</a></h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/25635684/1641352212752-0cf4cf3c-c99a-4f79-b3b1-a5282ea59780.png#clientId=uccbbe311-339e-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u2f0357ff&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=411&amp;originWidth=421&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=182314&amp;status=done&amp;style=none&amp;taskId=u5960f88f-c503-430f-8bfb-d4a13042016&amp;title=" alt="image.png"></p><ul><li><strong>全局唯一</strong>：必须保证id是全局性唯一（基本要求）</li><li><strong>高性能</strong>：高可用低延时，id生成响应要快，否则可能会成为业务瓶颈</li><li><strong>高可用</strong>：100%的可用性是不可能达到的，但是要无限接近于100%</li><li><strong>易用性</strong>：代码侵入性小，符合设计原则，在设计和实现上尽可能的简单</li><li><strong>趋势递增</strong>：最后趋势递增，无硬性要求，结合具体业务场景</li><li><strong>其他</strong>： 安全、有具体的业务含义、独立部署</li></ul><h1 id="二、分布式id解决方案有哪些？" tabindex="-1">二、分布式id解决方案有哪些？ <a class="header-anchor" href="#二、分布式id解决方案有哪些？" aria-hidden="true">#</a></h1><h2 id="_1、uuid" tabindex="-1">1、UUID <a class="header-anchor" href="#_1、uuid" aria-hidden="true">#</a></h2><p>uuid是Universally Unique Identifier（通用唯一标识符）的缩写。UUID包含32个16进制数字。 jdk自带UUID实现，一行代码搞定。</p><div class="language-java"><pre><code>UUID<span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>RFC4122中关于UUID的示例： <img src="https://cdn.nlark.com/yuque/0/2022/png/25635684/1641522931058-31a42163-c13b-4bb0-8318-bd7d27c3decd.png#clientId=ud14f2d89-40c9-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u82cda5dd&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=340&amp;originWidth=1400&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=60448&amp;status=done&amp;style=none&amp;taskId=uc4c70918-c275-4c38-ab5b-8f9aa9fff2f&amp;title=" alt="image.png"></p><p>5种不同版本的值分别对应的含义</p><ul><li>版本1：UUID是根据时间和节点ID（通常是MAC地址）生成</li><li>版本2：UUID是根据标识符（通常是组或用户id）</li><li>版本3、版本5：版本5-确定性UUID通过散列（hashing）名字空间（namespace）标识符和名称生成</li><li>版本4：UUID使用随机性或伪随机性生成。</li></ul><p>JDK中生成的UUID默认版本是4。</p><div class="language-java"><pre><code><span class="token class-name">UUID</span> uuid <span class="token operator">=</span> UUID<span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> version <span class="token operator">=</span> uuid<span class="token punctuation">.</span><span class="token function">version</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 4</span>
</code></pre></div><p>UUID可以保证唯一性，因为其生成规则包括MAC地址、时间搓、名字空间（namespace）、随机或伪随机、时序等元素，计算机基于这些规则生成的UUID是肯定不会重复的。 UUID虽然可以做到唯一性，但是不合适作为数据库的主键，数据库主键要约短约好，而UUID销耗存储空间比较大。UUID是无序的，影响数据库性能。</p><h3 id="优点：" tabindex="-1">优点： <a class="header-anchor" href="#优点：" aria-hidden="true">#</a></h3><ul><li>生成简单</li><li>本地生成无网络消耗</li><li>唯一性</li></ul><h3 id="缺点：" tabindex="-1">缺点： <a class="header-anchor" href="#缺点：" aria-hidden="true">#</a></h3><ul><li>无序的字符串，不具备趋势自增特性</li><li>没有具体业务含义</li><li>长度过长（16字节，128位，36位长度字符串），数据库存储空间大</li></ul><h2 id="_2-数据库主键自增" tabindex="-1">2.数据库主键自增 <a class="header-anchor" href="#_2-数据库主键自增" aria-hidden="true">#</a></h2><p>通过关系型数据库自增主键实现 以mysql为例（oracle可以使用序列（SEQUENCE））</p><div class="language-sql"><pre><code><span class="token keyword">CREATE</span> <span class="token keyword">DATABASE</span> <span class="token punctuation">`</span>SEQ_ID<span class="token punctuation">`</span><span class="token punctuation">;</span>
<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> SEQID<span class="token punctuation">.</span>SEQUENCE_ID <span class="token punctuation">(</span>
    id <span class="token keyword">bigint</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token keyword">unsigned</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">auto_increment</span><span class="token punctuation">,</span> 
    <span class="token keyword">value</span> <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">default</span> <span class="token string">&#39;&#39;</span><span class="token punctuation">,</span>
    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span>MyISAM<span class="token punctuation">;</span>

<span class="token keyword">insert</span> <span class="token keyword">into</span> SEQUENCE_ID<span class="token punctuation">(</span><span class="token keyword">value</span><span class="token punctuation">)</span>  <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">&#39;values&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p>当我们需要一个id时，向表中插入一条记录并返回主键id。</p><h3 id="优点：-1" tabindex="-1">优点： <a class="header-anchor" href="#优点：-1" aria-hidden="true">#</a></h3><ul><li>实现简单，id自增，数值类型查询速度快</li></ul><h3 id="缺点：-1" tabindex="-1">缺点： <a class="header-anchor" href="#缺点：-1" aria-hidden="true">#</a></h3><ul><li>数据库单点故障（使用集群，但是需要维护成本）</li><li>无法支持高并发</li><li>安全问题（可能通过id规律推测数据），增加数据库压力</li></ul><h2 id="_3、基于数据库集群模式" tabindex="-1">3、基于数据库集群模式 <a class="header-anchor" href="#_3、基于数据库集群模式" aria-hidden="true">#</a></h2><p>将上面的单机数据库更换为集群模式，变成主从模式集群。如何一个主节点宕机，可以变成双主模式集群，也就是说可以有两个节点生成id。</p><p>如果两个节点都从1开始，会产生重复的id？</p><p>解决方案：设置初始值和自增步长 MySQL_1 配置：</p><div class="language-sql"><pre><code><span class="token keyword">set</span> @<span class="token variable">@auto_increment_offset</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>     <span class="token comment">-- 起始值</span>
<span class="token keyword">set</span> @<span class="token variable">@auto_increment_increment</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token comment">-- 步长</span>
</code></pre></div><p>MySQL_2 配置：</p><div class="language-sql"><pre><code><span class="token keyword">set</span> @<span class="token variable">@auto_increment_offset</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>     <span class="token comment">-- 起始值</span>
<span class="token keyword">set</span> @<span class="token variable">@auto_increment_increment</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token comment">-- 步长</span>
</code></pre></div><p>这样他们产生的id就是 1、3、5 。。。 和2、4、6。。。</p><p>那如果集群后的性能还是扛不住高并发咋办？就要进行MySQL扩容增加节点，这是一个比较麻烦的事。 <img src="https://cdn.nlark.com/yuque/0/2022/png/25635684/1641462942816-49ba5325-223c-4d1d-9dcf-653728d40e92.png#clientId=ud14f2d89-40c9-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=249&amp;id=u5addae4e&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=412&amp;originWidth=748&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=51313&amp;status=done&amp;style=none&amp;taskId=u5425f82f-d763-42b7-a6e3-e67c8a7ff1a&amp;title=&amp;width=452" alt="image.png">​ 增加第三台MySQL实例需要人工修改一、二两台MySQL实例的起始值和步长，把第三台机器的ID起始生成位置设定在比现有最大自增ID的位置远一些，但必须在一、二两台MySQL实例ID还没有增长到第三台MySQL实例的起始ID值的时候，否则自增ID就要出现重复了，<strong>必要时可能还需要停机修改</strong>。</p><h3 id="优点：-2" tabindex="-1">优点： <a class="header-anchor" href="#优点：-2" aria-hidden="true">#</a></h3><ul><li>解决DB单点问题</li></ul><h3 id="缺点：-2" tabindex="-1">缺点： <a class="header-anchor" href="#缺点：-2" aria-hidden="true">#</a></h3><ul><li>不利于后续扩容，而且实际上单个数据库自身压力还是大，依旧无法满足高并发场景。</li></ul><h2 id="_4、基于数据库号段模式" tabindex="-1">4、基于数据库号段模式 <a class="header-anchor" href="#_4、基于数据库号段模式" aria-hidden="true">#</a></h2><p>号段模式也是当前分布式id主流实现方式之一，号段模式可以理解为从数据库中批量获取自增id，然后加载到内存中。</p><div class="language-sql"><pre><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> id_generator <span class="token punctuation">(</span>
  id <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  max_id <span class="token keyword">bigint</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">&#39;当前最大id&#39;</span><span class="token punctuation">,</span>
  step <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">&#39;号段的布长&#39;</span><span class="token punctuation">,</span>
  biz_type	<span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">&#39;业务类型&#39;</span><span class="token punctuation">,</span>
  version <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">&#39;版本号&#39;</span><span class="token punctuation">,</span>
  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span> 
</code></pre></div><p>biz_type ：代表不同业务类型 max_id ：当前最大的可用id step ：代表号段的长度 version ：是一个乐观锁，每次都更新version，保证并发时数据的正确性</p><div class="language-sql"><pre><code><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token punctuation">`</span>id_generator<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">,</span> <span class="token punctuation">`</span>max_id<span class="token punctuation">`</span><span class="token punctuation">,</span> <span class="token punctuation">`</span>step<span class="token punctuation">`</span><span class="token punctuation">,</span> <span class="token punctuation">`</span>version<span class="token punctuation">`</span><span class="token punctuation">,</span> <span class="token punctuation">`</span>biz_type<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">101</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>等这批号段用完，再次向数据库申请新号段，对max_id字段做一次update操作，update max_id=max_id+step,update成功则说明新号段获取成功，新的号段范围是（max_id,max_id+step]。</p><div class="language-sql"><pre><code><span class="token keyword">update</span> id_generator <span class="token keyword">set</span> max_id <span class="token operator">=</span> <span class="token comment">#{max_id+step}, version = version + 1 where version = # {version} and biz_type = XXX</span>
</code></pre></div><p>由于多业务端可能同时操作，所以采用版本号version乐观锁方式更新，这种分布式id生成不强依赖于数据库，不会频繁的访问数据库，对数据库的压力小很多。</p><h3 id="优点：-3" tabindex="-1">优点： <a class="header-anchor" href="#优点：-3" aria-hidden="true">#</a></h3><ul><li>解决了方式2中数据库频繁访问的问题</li></ul><h3 id="缺点：-3" tabindex="-1">缺点： <a class="header-anchor" href="#缺点：-3" aria-hidden="true">#</a></h3><ul><li>安全问题（可能通过id规律推测数据）、单点故障（集群解决）、id没有业务含义</li></ul><h2 id="_5、基于redis模式" tabindex="-1">5、基于redis模式 <a class="header-anchor" href="#_5、基于redis模式" aria-hidden="true">#</a></h2><p>基于NoSQL实现，实现原来就是利用redis的incr命令来实现id的原子性自增。</p><div class="language-sql"><pre><code><span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span>:<span class="token number">6379</span><span class="token operator">&gt;</span> <span class="token keyword">set</span> seq_id <span class="token number">1</span>     <span class="token comment">// 初始化自增ID为1</span>
OK
<span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span>:<span class="token number">6379</span><span class="token operator">&gt;</span> incr seq_id      <span class="token comment">// 增加1，并返回递增后的数值</span>
<span class="token punctuation">(</span><span class="token keyword">integer</span><span class="token punctuation">)</span> <span class="token number">2</span>
</code></pre></div><p>为了高可用和高并发，我们有时可以使用Redis Cluser。Redis Cluser是redis官方提供的redis集群解决方案（3.0+版本）。 使用redis需要注意一点，就是考虑redis持久化的问题，redis有两种持久化方法RDB和AOF。</p><ul><li>RDB会定时打一个快照进行持久化，假如连续自增但redis没有及时持久化，redis宕机，重启redis后会出现id重复的情况。</li><li>AOF会对每条写命令进行持久化，即使reids宕机也不会出现重复id的情况，但由于incr命令的特殊性，会导致redis重启恢复数据的时间过长。</li></ul><h3 id="优点：-4" tabindex="-1">优点： <a class="header-anchor" href="#优点：-4" aria-hidden="true">#</a></h3><ul><li>基于内存性能不错并且生成的 ID 是有序递增的</li></ul><h3 id="缺点：-4" tabindex="-1">缺点： <a class="header-anchor" href="#缺点：-4" aria-hidden="true">#</a></h3><ul><li>同数据库自增</li></ul><h2 id="_6、基于mongodb-objectid" tabindex="-1">6、基于MongoDB ObjectId <a class="header-anchor" href="#_6、基于mongodb-objectid" aria-hidden="true">#</a></h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/25635684/1641522799488-8fed8495-f4c6-4b1c-bb51-312fcdd1991b.png#clientId=ud14f2d89-40c9-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u9317c355&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=185&amp;originWidth=793&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=15759&amp;status=done&amp;style=none&amp;taskId=ud1438b19-e177-4997-bf40-db51edeecd9&amp;title=" alt="image.png"> MongoDB ObjectId 一共需要 12 个字节存储：</p><ul><li>0~3：时间戳</li><li>3~6： 代表机器 ID</li><li>7~8：机器进程 ID</li><li>9~11 ：自增值</li></ul><h3 id="优点-：" tabindex="-1">优点 ： <a class="header-anchor" href="#优点-：" aria-hidden="true">#</a></h3><ul><li>性能不错并且生成的 ID 是有序递增的</li></ul><h3 id="缺点-：" tabindex="-1">缺点 ： <a class="header-anchor" href="#缺点-：" aria-hidden="true">#</a></h3><ul><li>需要解决重复 ID 问题（当机器时间不对的情况下，可能导致会产生重复 ID） 、有安全性问题（ID 生成有规律性）</li></ul><h2 id="_7、基于snowflake（雪花算法）模式" tabindex="-1">7、基于snowflake（雪花算法）模式 <a class="header-anchor" href="#_7、基于snowflake（雪花算法）模式" aria-hidden="true">#</a></h2><p>Snowflake是Twitter开源的分布式id生成算法。Snowflake由64bit的二进制数字组成，这64bit的二进制被分成了几部分，每一部分存储的数据都有特定的含义： <img src="https://cdn.nlark.com/yuque/0/2022/png/25635684/1641523377646-d307456a-c03e-4353-aa4f-729cf50e7567.png#clientId=ud14f2d89-40c9-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=233&amp;id=u03141c11&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=242&amp;originWidth=843&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=64423&amp;status=done&amp;style=none&amp;taskId=u3f4ed87d-9d6e-4e07-b97a-c9f77e45758&amp;title=&amp;width=810.5" alt="image.png"> Snowflake生成的是Long类型的ID，一个Long类型占8个字节，每个字节占8比特，也就是说一个Long类型占64个比特。 Snowflake ID组成结构：正数位（占1比特）+ 时间戳（占41比特）+ 机器ID（占5比特）+ 数据中心（占5比特）+ 自增值（占12比特），总共64比特组成的一个Long类型。 ​</p><ul><li><strong>第 0 位</strong>： 符号位（标识正负），始终为 0，没有用，不用管。</li><li><strong>第 1~41 位</strong> ：时间戳部分，一共 41 位，用来表示时间戳，单位是毫秒，可以支撑 2 ^41 毫秒（约 69 年）</li><li><strong>第 42~52 位</strong> ：工作机器id也被叫做workId，一共 10 位，一般来说，前 5 位表示机房 ID，后 5 位表示机器 ID（实际项目中可以根据实际情况调整）。这样就可以区分不同集群/机房的节点。</li><li><strong>第 53~64 位</strong> ：序列号部分，12 位，用来表示序列号。 序列号为自增值，代表单台机器每毫秒能够产生的最大 ID 数(2^12 = 4096),也就是说单台机器每毫秒最多可以生成 4096 个 唯一 ID。</li></ul><h3 id="优点：-5" tabindex="-1">优点： <a class="header-anchor" href="#优点：-5" aria-hidden="true">#</a></h3><ul><li>生成速度比较快、生成的 ID 有序递增、比较灵活（可以对 Snowflake 算法进行简单的改造比如加入业务 ID）</li></ul><h3 id="缺点：-5" tabindex="-1">缺点： <a class="header-anchor" href="#缺点：-5" aria-hidden="true">#</a></h3><ul><li>需要解决重复 ID 问题（依赖时间，当机器时间不对的情况下，可能导致会产生重复 ID）。</li></ul><div class="language-java"><pre><code><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Random</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">ThreadLocalRandom</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * twitter的snowflake算法 -- java实现
 *
 * @author beyond
 * @date 2016/11/26
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SnowFlake</span> <span class="token punctuation">{</span>

    <span class="token comment">/**
     * 起始的时间戳
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token keyword">long</span> START_STMP <span class="token operator">=</span> <span class="token number">1288834974657L</span><span class="token punctuation">;</span>

    <span class="token comment">/**
     * 每一部分占用的位数
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token keyword">long</span> SEQUENCE_BIT <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span> <span class="token comment">//序列号占用的位数</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token keyword">long</span> MACHINE_BIT <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>   <span class="token comment">//机器标识占用的位数</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token keyword">long</span> DATACENTER_BIT <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token comment">//数据中心占用的位数</span>

    <span class="token comment">/**
     * 每一部分的最大值
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token keyword">long</span> MAX_DATACENTER_NUM <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1L</span> <span class="token operator">^</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1L</span> <span class="token operator">&lt;&lt;</span> DATACENTER_BIT<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token keyword">long</span> MAX_MACHINE_NUM <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1L</span> <span class="token operator">^</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1L</span> <span class="token operator">&lt;&lt;</span> MACHINE_BIT<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token keyword">long</span> MAX_SEQUENCE <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1L</span> <span class="token operator">^</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1L</span> <span class="token operator">&lt;&lt;</span> SEQUENCE_BIT<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/**
     * 每一部分向左的位移
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token keyword">long</span> MACHINE_LEFT <span class="token operator">=</span> SEQUENCE_BIT<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token keyword">long</span> DATACENTER_LEFT <span class="token operator">=</span> SEQUENCE_BIT <span class="token operator">+</span> MACHINE_BIT<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token keyword">long</span> TIMESTMP_LEFT <span class="token operator">=</span> DATACENTER_LEFT <span class="token operator">+</span> DATACENTER_BIT<span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token keyword">long</span> datacenterId<span class="token punctuation">;</span>  <span class="token comment">//数据中心</span>
    <span class="token keyword">private</span> <span class="token keyword">long</span> machineId<span class="token punctuation">;</span>     <span class="token comment">//机器标识</span>
    <span class="token keyword">private</span> <span class="token keyword">long</span> sequence <span class="token operator">=</span> <span class="token number">0L</span><span class="token punctuation">;</span> <span class="token comment">//序列号</span>
    <span class="token keyword">private</span> <span class="token keyword">long</span> lastStmp <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1L</span><span class="token punctuation">;</span><span class="token comment">//上一次时间戳</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Random</span> RANDOM <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


    <span class="token keyword">public</span> <span class="token class-name">SnowFlake</span><span class="token punctuation">(</span><span class="token keyword">long</span> datacenterId<span class="token punctuation">,</span> <span class="token keyword">long</span> machineId<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>datacenterId <span class="token operator">&gt;</span> MAX_DATACENTER_NUM <span class="token operator">||</span> datacenterId <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">&quot;datacenterId can&#39;t be greater than MAX_DATACENTER_NUM or less than 0&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>machineId <span class="token operator">&gt;</span> MAX_MACHINE_NUM <span class="token operator">||</span> machineId <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">&quot;machineId can&#39;t be greater than MAX_MACHINE_NUM or less than 0&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>datacenterId <span class="token operator">=</span> datacenterId<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>machineId <span class="token operator">=</span> machineId<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 产生下一个ID
     *
     * @return
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">long</span> <span class="token function">nextId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">long</span> currStmp <span class="token operator">=</span> <span class="token function">getNewstmp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 解决时间回拨问题</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>currStmp <span class="token operator">&lt;</span> lastStmp<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">long</span> offset <span class="token operator">=</span> lastStmp <span class="token operator">-</span> currStmp<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>offset <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    <span class="token comment">//时间偏差大小小于5ms，则等待两倍时间</span>
                    <span class="token function">wait</span><span class="token punctuation">(</span>offset <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    currStmp <span class="token operator">=</span> <span class="token function">getNewstmp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>currStmp <span class="token operator">&lt;</span> lastStmp<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        <span class="token comment">//还是小于，抛异常并上报</span>
                        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">&quot;Clock moved backwards.  Refusing to generate id&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">&quot;Clock moved backwards.  Refusing to generate id&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">&quot;Clock moved backwards.  Refusing to generate id&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>currStmp <span class="token operator">==</span> lastStmp<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">//相同毫秒内，序列号自增</span>
            sequence <span class="token operator">=</span> <span class="token punctuation">(</span>sequence <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> MAX_SEQUENCE<span class="token punctuation">;</span>
            <span class="token comment">//同一毫秒的序列数已经达到最大</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>sequence <span class="token operator">==</span> <span class="token number">0L</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 序列号生成添加随机源，会稍微减少同一个毫秒内能产生的最大ID数量。</span>
                sequence<span class="token operator">=</span>RANDOM<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                currStmp <span class="token operator">=</span> <span class="token function">getNextMill</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token comment">//序列号生成添加随机源，会稍微减少同一个毫秒内能产生的最大ID数量。</span>
            sequence <span class="token operator">=</span> <span class="token class-name">ThreadLocalRandom</span><span class="token punctuation">.</span><span class="token function">current</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextLong</span><span class="token punctuation">(</span><span class="token number">1L</span><span class="token punctuation">,</span> <span class="token number">3L</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        lastStmp <span class="token operator">=</span> currStmp<span class="token punctuation">;</span>

        <span class="token keyword">return</span> <span class="token punctuation">(</span>currStmp <span class="token operator">-</span> START_STMP<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> TIMESTMP_LEFT <span class="token comment">//时间戳部分</span>
                <span class="token operator">|</span> datacenterId <span class="token operator">&lt;&lt;</span> DATACENTER_LEFT       <span class="token comment">//数据中心部分</span>
                <span class="token operator">|</span> machineId <span class="token operator">&lt;&lt;</span> MACHINE_LEFT             <span class="token comment">//机器标识部分</span>
                <span class="token operator">|</span> sequence<span class="token punctuation">;</span>                             <span class="token comment">//序列号部分</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">long</span> <span class="token function">getNextMill</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">long</span> mill <span class="token operator">=</span> <span class="token function">getNewstmp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>mill <span class="token operator">&lt;=</span> lastStmp<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            mill <span class="token operator">=</span> <span class="token function">getNewstmp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> mill<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">long</span> <span class="token function">getNewstmp</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">SnowFlake</span> snowFlake <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SnowFlake</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>snowFlake<span class="token punctuation">.</span><span class="token function">nextId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="_8、百度（uid-generator）" tabindex="-1">8、百度（uid-generator） <a class="header-anchor" href="#_8、百度（uid-generator）" aria-hidden="true">#</a></h2><p>uid-generator是由百度技术部开发 uid-generator是基于Snowflake算法实现的，与原始的snowflake算法不同在于，uid-generator支持自定义时间戳、工作机器ID和 序列号 等各部分的位数，而且uid-generator中采用用户自定义workId的生成策略。 uid-generator需要与数据库配合使用，需要新增一个WORKER_NODE表。当应用启动时会向数据库表中去插入一条数据，插入成功后返回的自增ID就是该机器的workId数据由host，port组成。 <strong>对于uid-generator ID组成结构</strong>： workId，占用了22个bit位，时间占用了28个bit位，序列化占用了13个bit位，需要注意的是，和原始的snowflake不太一样，时间的单位是秒，而不是毫秒，workId也不一样，而且同一应用每次重启就会消费一个workId。</p><h2 id="_9、美团（leaf）" tabindex="-1">9、美团（Leaf） <a class="header-anchor" href="#_9、美团（leaf）" aria-hidden="true">#</a></h2><p><a href="https://github.com/Meituan-Dianping/Leaf" target="_blank" rel="noopener noreferrer">Leaf</a>由美团开发</p><p>Leaf 提供了 <strong>号段模式</strong> 和 <strong>Snowflake(雪花算法)</strong> 这两种模式来生成分布式 ID。并且，它支持双号段，还解决了雪花 ID 系统时钟回拨问题。不过，时钟问题的解决需要弱依赖于 Zookeeper 。</p><h2 id="_10、滴滴（tinyid）" tabindex="-1">10、滴滴（Tinyid） <a class="header-anchor" href="#_10、滴滴（tinyid）" aria-hidden="true">#</a></h2><p><a href="https://github.com/didi/tinyid" target="_blank" rel="noopener noreferrer">Tinyid</a>是滴滴开源的一款基于数据库号段模式的唯一 ID 生成器。</p></div></div><footer class="page-footer" data-v-8fcebc32 data-v-5c96fb00><div class="edit" data-v-5c96fb00><div class="edit-link" data-v-5c96fb00 data-v-55695e90><!----></div></div><div class="updated" data-v-5c96fb00><!----></div></footer><!----><!--[--><!--]--></div></main></div><!----><!--]--></div><div class="theme-select" data-v-3eaa5914><ul data-v-3eaa5914><li class="active" data-v-3eaa5914> ☀️ </li><li class="" data-v-3eaa5914> 🌑 </li></ul></div><div class="site-footer" data-v-3eaa5914> MIT Licensed | Copyright © 2022 <a class="vitepress" href="https://github.com/shadowLQ/blog">时刻准备着</a><br> Powered by <a class="vitepress" target="_blank" href="//vitepress.vuejs.org/">VitePress</a></div><!--]--></div>
    <script>__VP_HASH_MAP__ = JSON.parse("{\"index.md\":\"bdcc45fc\",\"pages_about.md\":\"8f79ad74\",\"pages_archives.md\":\"1f0b42e6\",\"pages_tags.md\":\"520d0601\",\"posts_bigdecimal的使用与注意事项.md\":\"981eff7f\",\"posts_docker.md\":\"b1b5f667\",\"posts_mac和window互传文件.md\":\"c794345c\",\"posts_yarn.md\":\"d2981a53\",\"posts_常用分布式id解决方案.md\":\"9856da27\"}")</script>
    <script type="module" async src="/blog/assets/app.696abebf.js"></script>
    
  </body>
</html>